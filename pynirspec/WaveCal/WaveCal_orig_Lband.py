import atmopt.rfm_tools as rfm
import subprocess as sp
import re
import numpy as np
import numpy.fft as fft
import matplotlib.pyplot as plt
import pynirspec.pynirspec as pn
import NirspecTel as nt
from lmfit import minimize, Parameters, Parameter, report_fit

class Model():
    def __init__(self,**kwargs):
        self.Envi = rfm.Environment()
        self.rfm_exe = self.Envi.exe_file
        self.outname = 'rfm.tra'

    def RFM(self,**kwargs):
        self.makeDriverFile('rfm.drv',outname=self.outname,**kwargs)
        output = sp.check_output([self.rfm_exe])
        self.spectrum = self.readFromFile(self.outname)
        self.radiance = self.readFromFile('rfm.rad')
        return 1
        
    def makeDriverFile(self,filename,pwv=2.,am=1.05,wmin=2200.,wmax=2210.,
                       sampling=0.01,alt=4.15,
                       mols=['H2O','CO2','O3','CO','CH4'],
                       outname='rfm.tra',atm_files=None):

        if atm_files is None:
            atm_files = [self.Envi.atm_file]
        hitran_path = self.Envi.hit_file
        
        file = open(filename, 'w')

        file.write('*HDR\n       ')
        file.write('RFM Driver file generated by RFM tools.\n')
        file.write('*FLG\n       ')
        file.write('OBS TRA RAD ZEN DBL      !\n')
        file.write('*SPC\n       ')
        file.write(str(wmin)+' '+str(wmax)+' '+str(sampling)+'\n')
        file.write('*GAS\n       ')
        for mol in mols:
            file.write(mol+' ')
        file.write('\n')
        file.write('*ATM\n      ')
        for atm_file in atm_files:
            file.write(atm_file+'\n')
        file.write('*TAN\n      ')
        file.write(str(am)+'\n')
        file.write('*HIT\n      ')
        file.write(hitran_path+'\n')
        file.write('*OBS\n      ')
        file.write(str(alt)+'\n')
        file.write('*TRA\n      ')
        file.write(self.outname+'\n')
        file.write('*RAD\n      ')
        file.write('rfm.rad\n')
        file.write('*END\n')

        file.close()

    def readFromFile(self,filename):
        
        ccond = re.compile('\!')
        
        file = open(filename,'r')
        lines = file.readlines()

        first_line_read = False

        data = np.array([])
        for line in lines:
            #Is it a comment line?
            if not ccond.search(line):
                #Is it the first line?
                if not first_line_read:
                    first_line = line.split()
                    npoints  = int(first_line[0])
                    wmin     = float(first_line[1])
                    sampling = float(first_line[2])
                    wmax     = float(first_line[3])
                    label    = first_line[4]
                    label_len = len(label)
                    #Remove inverted commas
                    label = label[1:label_len-1]

                    first_line_read = True
                else:
                    data = np.append(data,[float(s) for s in line.split()])
 
        file.close()

        wave = np.linspace(wmin,wmax,npoints)

        #Everything in order of increasing wavelength
        return {'wavelength':1e4/wave[::-1],'wavenumber':wave[::-1],label:data[::-1]}
        
    def blur(self,rpower=1e5):
        wave = self.spectrum['wavelength']
        tran = self.spectrum['Transmission']
        radi = self.radiance['Radiance']
        
        wmin = wave.min()
        wmax = wave.max()
        
        nx = wave.size
        x  = np.arange(nx)
        
        A = wmin
        B = np.log(wmax/wmin)/nx
        wave_constfwhm = A*np.exp(B*x)

        tran_constfwhm = np.interp(wave_constfwhm, wave, tran)        
        radi_constfwhm = np.interp(wave_constfwhm, wave, radi)  
        
        #Sanity check that the FWHM is indeed constant
        dwdx_constfwhm = np.diff(wave_constfwhm)
        fwhm_pix = wave_constfwhm[1:]/rpower/dwdx_constfwhm
        if (fwhm_pix.min()-fwhm_pix.max())/fwhm_pix.max() > 1e-5: 
            #This should not happen
            warnings.warn('The FWHM is not constant in units of pixels.')
        
        fwhm_pix  = fwhm_pix[0]
        sigma_pix = fwhm_pix/2.3548
        kx = np.arange(nx)-(nx-1)/2.
        kernel = 1./(sigma_pix*np.sqrt(2.*np.pi))*np.exp(-kx**2/(2.*sigma_pix**2)) 
        
        tran_conv = fft.ifft(fft.fft(tran_constfwhm)*np.conj(fft.fft(kernel)))
        tran_conv = fft.fftshift(tran_conv).real
        tran_oldsampling = np.interp(wave,wave_constfwhm,tran_conv)

        radi_conv = fft.ifft(fft.fft(radi_constfwhm)*np.conj(fft.fft(kernel)))
        radi_conv = fft.fftshift(radi_conv).real
        radi_oldsampling = np.interp(wave,wave_constfwhm,radi_conv)

        self.obs_spectrum = {'wavelength':wave,'wavenumber':1e4/wave, 
                             'Transmission':tran_oldsampling,'Radiance':radi_oldsampling}

        return self.obs_spectrum

    def getSpec(self):
        return self.obs_spectrum

    def plot(self,unit='cm-1'):
        if unit=='micron':
            plt.plot(self.obs_spectrum['wavelength'],self.obs_spectrum['Transmission'])
            plt.show()
        elif unit=='cm-1':
            plt.plot(self.obs_spectrum['wavenumber'],self.obs_spectrum['Transmission'])
            plt.show()
        else:
            raise Exception("Unknown unit in model plot")

class QuickRed():
    def __init__(self,flat_range=None, flat_dark_range=None, dark_range=None,
                sci_range=None, std_range=None, path=None, base=None,level1=True,level2=True,
                level1_path='L1FILES',shift=0.0, dtau=0.0, save_dark=False, save_flat=False, SettingsFile=None,
                sci_tname=None, std_tname=None, hold_plots=True, hold=True, **kwargs):

        if (hold == False):
            hold_plots = False

        self.save_dark = save_dark
        self.save_flat = save_flat

        sci_range1 = sci_range
        self.shift       = shift
        self.dtau        = dtau
        self.level1_path = level1_path

        self.SettingsFile = SettingsFile

        self.flat_dark_names = pn.makeFilelist(base,flat_dark_range,path=path)
        self.obs_dark_names  = pn.makeFilelist(base,dark_range,path=path)
        self.flat_names      = pn.makeFilelist(base,flat_range,path=path)
        self.sci_names1      = pn.makeFilelist(base,sci_range1,path=path)
        self.std_names       = pn.makeFilelist(base,std_range,path=path)

        self.mode  = 'SciStd'
        self.tdict = {'science':self.sci_names1,'standard':self.std_names}
        self.ndict = {'science':sci_tname, 'standard':std_tname}
        self.hold_plots = hold_plots

        if level1:
            self._level1()


    def _level1(self):
        FDark = pn.Dark(self.flat_dark_names)
        ODark = pn.Dark(self.obs_dark_names,save=self.save_dark)
        OFlat = pn.Flat(self.flat_names, dark=FDark,save=self.save_flat, SettingsFile=self.SettingsFile)

        level1_files = {}
        for key in self.tdict.keys():
            ONod    = pn.Nod(self.tdict[key],flat=OFlat,dark=ODark, tname=self.ndict[key], SettingsFile=self.SettingsFile) 
            norders = ONod.getNOrders()
            target_files = []
            for i in np.arange(norders):
                print '### Processing order', i+1
                OOrder   = pn.Order(ONod,onum=i+1,write_path='foo')
                print '### 2D order extracted'
                OSpec1D  = pn.Spec1D(OOrder,sa=True,write_path='foo')
                OWaveCal = pn.WaveCal(OSpec1D.file,path='wave_o',am=OSpec1D.airmass, hp=self.hold_plots)


class WaveCal():
    def __init__(self, ObsFilename=None, wave_min=None, wave_max=None, cull=50, am=1.0, H2O_scale=0.5, CO_scale=1.0):
		## SETUP MODEL ATMOSPHERE ##
		Envi = rfm.Environment()
		A = rfm.Atmosphere(filename=Envi.atm_file)
		A.scaleProf('H2O', H2O_scale)
		A.scaleProf('CO', CO_scale)
		#        A.scaleProf('CH4', 1.0)
		#        A.scaleProf('CO2', 1.0)
		A.writeAll('tmp.atm')
		self.A = A

		M = Model()
		M.RFM(atm_files=['tmp.atm'],wmin=1e4/wave_max,wmax=1e4/wave_min, am=am)
		M.blur(rpower=25000.)
		self.M = M
		#        plt.figure()
		#        plt.plot(self.M.spectrum['wavelength'], self.M.spectrum['Transmission']/np.mean(self.M.spectrum['Transmission']))
		#        print self.M.spectrum['Transmission']
		#        assert(0==1)

		## GET MODEL SKY SPECTRA ##
		ModInfo = M.getSpec()
		self.WaveMod  = ModInfo['wavelength']
		#        self.SkyRadMod = ModInfo['Radiance'] / np.median(ModInfo['Radiance'])
		self.SkyRadMod = ModInfo['Radiance'] / np.amax(ModInfo['Radiance'])
		scale = np.amax(self.SkyRadMod)


		## GET OBSERVED SKY ##
		ObsInfo    = nt.WaveOrder(ObsFilename).getData()
		WaveObsPos = np.array(ObsInfo['wl_pos'])
		SkyObsPos  = np.array(ObsInfo['sky_pos']) #/ np.median(ObsInfo['sky_pos'])  # L BAND
		#        SkyObsPos  = np.array(ObsInfo['flux_pos']) / np.median(ObsInfo['flux_pos']) # K BAND
		WaveObsNeg = np.array(ObsInfo['wl_neg'])
		SkyObsNeg  = np.array(ObsInfo['sky_neg']) / np.median(ObsInfo['sky_neg'])  # L BAND
		#        SkyObsNeg  = np.array(ObsInfo['flux_neg']) / np.median(ObsInfo['flux_neg']) # K BAND

		#plt.plot(WaveObsPos, SkyObsPos)
		#plt.show()

		## FIT OUT CONTINUUM ## (DP 21 JAN 16)
		wn_data_all = [WaveObsPos, WaveObsNeg]
		flux_data_all = [SkyObsPos, SkyObsNeg]
		merp = 16
		factor = 64
		posneg = 0
		baseline_pos, baseline_neg = np.ones(np.size(WaveObsPos)), np.ones(np.size(WaveObsNeg))
		#        SkyObsPos_contrmv, SkyObsNeg_contrmv = np.array(np.size(SkyObsPos)), np.array(np.size(SkyObsNeg))
		for wn_data, flux_data in zip(wn_data_all, flux_data_all) : 
			points_flux, points_wn, points_count =np.zeros(merp), np.zeros(merp), np.arange(merp)
			for count in points_count :
				startpoint = count*factor
				endpoint = (count+1)*factor
				if count == 0 : startpoint = 10
				if count == 15 : endpoint = 1024-10
				points_flux[count]=np.min(flux_data[startpoint:endpoint])
				loc=np.argmax(flux_data[startpoint:endpoint])
	#                points_wn[count]=wn_data[loc+startpoint]
				points_wn[count]=loc+startpoint
			coeff = np.polyfit(points_wn, points_flux, 1)   
			print coeff
#            if posneg == 0 : baseline_pos = coeff[1] + coeff[0]*wn_data# + coeff[1]*wn_data**2 + coeff[0]*wn_data**3
#            if posneg == 1 : baseline_neg = coeff[1] + coeff[0]*wn_data# + coeff[1]*wn_data**2 + coeff[0]*wn_data**3
			if posneg == 0 : baseline_pos = coeff[1] + coeff[0]*np.arange(1024)# + coeff[1]*np.arange(1024)**2 + coeff[0]*np.arange(1024)**3
			if posneg == 1 : baseline_neg = coeff[1] + coeff[0]*np.arange(1024)# + coeff[1]*np.arange(1024)**2 + coeff[0]*np.arange(1024)**3
			posneg += 1
#        SkyObsPos_contrmv, SkyObsNeg_contrmv = SkyObsPos / baseline_pos, SkyObsNeg / baseline_neg
		SkyObsPos_contrmv, SkyObsNeg_contrmv = SkyObsPos, SkyObsNeg
#        plt.figure()
#        plt.plot(SkyObsPos, hold=True)
#        plt.plot(baseline_pos, hold=True)
#        plt.show()
#        plt.figure()
#        plt.plot(SkyObsNeg, hold=True)
#        plt.plot(baseline_neg, hold=True)
#        plt.show()
        
		self.ObsLabelPN = ['pos', 'neg']
		self.WaveObsPN = [WaveObsPos, WaveObsNeg]
		SkyObsPos_contrmv_scaled = SkyObsPos_contrmv / np.amax(SkyObsPos_contrmv) #scale * SkyObsPos_contrmv
		SkyObsNeg_contrmv_scaled = SkyObsNeg_contrmv / np.amax(SkyObsNeg_contrmv) #scale * SkyObsNeg_contrmv
		self.Pixels = [np.arange(len(WaveObsPos)), np.arange(len(WaveObsNeg))]
		self.SkyObsPN_orig  = [SkyObsPos, SkyObsNeg]
		self.SkyObsPN  = [SkyObsPos_contrmv_scaled, SkyObsNeg_contrmv_scaled]
#        print np.shape(self.SkyObsPN_orig)
#        print np.shape(SkyObsPos), np.shape(SkyObsNeg)
#        print np.shape(SkyObsPos_contrmv_scaled), np.shape(SkyObsNeg_contrmv_scaled)
#        print np.shape(self.SkyObsPN)
#        plt.figure()
#        plt.plot(SkyObsPos_contrmv_scaled)
#        plt.plot(self.SkyRadMod)
#        plt.show()
		self.GoodFit = [False, False]

		self.Coefs, self.WaveObsPN = self.FitInitDS(self.WaveObsPN, self.ObsLabelPN)

		while(True):
			RawInput = raw_input('>> ').replace(" ", "").lower()

			if (RawInput == 'quit'):
				break

			if (RawInput == 'pos'):
				RawInput2 = raw_input("Pos. Coefficients?: ").split(",")
				self.Coefs[0] = np.array(RawInput2, dtype=np.float)
				self.WaveObsPN[0] = self.DSFunc(self.Pixels[0], self.Coefs[0])
				self.PlotModObs(self.WaveMod, self.SkyRadMod, self.WaveObsPN[0], self.SkyObsPN[0], self.ObsLabelPN[0])
	
			if (RawInput == 'neg'):
				RawInput2 = raw_input("Neg. Coefficients?: ").split(",")
				self.Coefs[1] = np.array(RawInput2, dtype=np.float)
				self.WaveObsPN[1] = self.DSFunc(self.Pixels[1], self.Coefs[1])
				self.PlotModObs(self.WaveMod, self.SkyRadMod, self.WaveObsPN[1], self.SkyObsPN[1], self.ObsLabelPN[1])

			if (RawInput == 'fit'):
				for i in range(0,len(self.Coefs)):
					if (self.GoodFit[i] != True):
						self.Coefs[i], self.WaveObsPN[i] = self.FitDS(self.WaveMod, self.SkyRadMod, self.SkyObsPN[i], self.Coefs[i])
						self.PlotModObs(self.WaveMod, self.SkyRadMod, self.WaveObsPN[i], self.SkyObsPN[i], self.ObsLabelPN[i])
						RawInput2 = raw_input("Good Fit? (yes/no): ").replace(" ", "").lower()
						while (True):
							if (RawInput2 == 'yes'):
								self.GoodFit[i] = True
								break
							if (RawInput2 == 'no'):
								break
							else:
								print "Please type yes or no."
								break
					else:
						print ''
						print '## Dispersion Solution for ' + self.ObsLabelPN[i] + ' position is good.'

			if (RawInput == 'pf'):
				self.PrintCoefs()

    def PrintCoefs(self):
        
        Clab = ['A = ', 'B = ', 'C = ', 'D = ', 'E = ']

        for coef, label, goodf in zip(self.Coefs,self.ObsLabelPN, self.GoodFit):
            print ''
            print 'Position = ', label
            print 'Good Fit = ', goodf
            print '-------------------'
            for i in range(0,len(coef)):
                print Clab[i], coef[i]
            print ''
            print "{}, {}, {}, {}, {}".format(coef[0],coef[1],coef[2],coef[3],coef[4])
            print ''

    def PlotModObs(self, wave_mod, flux_mod, wave_obs, flux_obs, label, block=False):
        plt.close()
        plt.figure(figsize=(20, 10))
        plt.plot(wave_mod, flux_mod, color='blue')
        plt.plot(wave_obs, flux_obs, color='red')
        x1,x2,y1,y2 = plt.axis()
        plt.axis((x1, x2, np.amin([np.amin(flux_mod), np.amin(flux_obs)]), np.amax(flux_mod)))
        plt.title(label)
        plt.show()
        #plt.savefig('/home/dpiskorz/Desktop/temp.pdf')

    def FitInitDS(self, WaveLengths, Labels):
        porder = 1
        Coefs, WaveLengths_fit = [], []

        print 'Initial Coefficients'
        print '===================='

        for wl, label in zip(WaveLengths, Labels):
            pixels = np.arange(len(wl))

            coef = np.polyfit(pixels, wl, porder)[::-1]
            wl_fit = self.DSFunc(pixels, coef)

            print '# ' + label + ' #'
            print '---------------'
            for i in range(0, porder+1):
                print i, coef[i]
            print ''

            plt.plot(pixels, wl, 'ko')
            plt.plot(pixels, wl_fit)
            plt.show()

            Coefs.append(coef)
            WaveLengths_fit.append(wl_fit)

        return Coefs, WaveLengths_fit

    def DSFunc(self, pixels, Coefs):

        WaveOut = np.zeros(len(pixels))
        for i in range(0,len(Coefs)):
            if i <= 1:
                WaveOut = WaveOut + Coefs[i]*(pixels)**i
            else:
                WaveOut = WaveOut + Coefs[i]*(pixels/1000.)**i

        return WaveOut

    def residual(self, params, flux_data, wl_model, flux_model):
        npix = len(flux_data)
        pixels = np.arange(npix)
    
        Coefs = [params['A'].value, params['B'].value, params['C'].value, params['D'].value, params['E'].value]
        wl_fit = self.DSFunc(pixels, Coefs)

        flux_model_fit = np.interp(wl_fit, wl_model, flux_model, left=flux_model[0], right=flux_model[-1])
             
        index_use = np.where(flux_data > 0.005)
            
        residual = np.subtract(flux_model_fit[index_use], flux_data[index_use])
            
        return (residual)

    def FitDS(self, WLmod, Fmod, Fobs, CoefsInit):

        params = Parameters()
        params.add('A',value=CoefsInit[0], vary=True)   ## set ranges on this if necessary
        params.add('B',value=CoefsInit[1], vary=True)
        params.add('C',value=1e-5, vary=True)
        params.add('D',value=1e-6, vary=True)
        params.add('E',value=1e-6, vary=True) 
        
        
        #print params
        #print '====='
        #print 'Fobs'
        #for p in Fobs: print p
        #print '====='
        #print 'WLmod'
        #for p in WLmod: print p
        #print '====='
        #print 'Fmod'
        #for p in Fmod: print p
        result = minimize(self.residual, params, args=(Fobs, WLmod, Fmod), method='powell') #'powell') #'least-sq')
        
        params = result.params
        
        print ''
        print '-----'
        #print report_fit(result)
        print 'A = ', params['A']
        print 'B = ', params['B'] 
        print 'C = ', params['C']
        print 'D = ', params['D']
        print 'E = ', params['E']
        #print 'R = ', params['R']
        print 'RedChi / Success = ', result.redchi, ' / ', result.success
        print ''
        print '====='
        
        #Coefs = result.x
        Coefs = [params['A'].value, params['B'].value, params['C'].value, params['D'].value, params['E'].value]
        pixels = np.arange(len(Fobs))
        WLobs = self.DSFunc(pixels, Coefs)

        return Coefs, WLobs



