# -*- coding: utf-8 -*-
"""
Created on Mon Feb  8 09:39:56 2016

@author: dpiskorz
"""

import atmopt.rfm_tools as rfm
import subprocess as sp
import re
import numpy as np
import numpy.fft as fft
import matplotlib.pyplot as plt
import pynirspec.pynirspec as pn
import NirspecTel as nt
from lmfit import minimize, Parameters, Parameter

class Model():
    def __init__(self,**kwargs):
        self.Envi = rfm.Environment()
        self.rfm_exe = self.Envi.exe_file
        self.outname = 'rfm.tra'

    def RFM(self,**kwargs):
        self.makeDriverFile('rfm.drv',outname=self.outname,**kwargs)
        output = sp.check_output([self.rfm_exe])
        self.spectrum = self.readFromFile(self.outname)
        self.radiance = self.readFromFile('rfm.rad')
        return 1
        
    def makeDriverFile(self,filename,pwv=2.,am=1.05,wmin=2200.,wmax=2210.,
                       sampling=0.01,alt=4.15,
                       mols=['H2O','CO2','O3','CO','CH4'],
                       outname='rfm.tra',atm_files=None):

        if atm_files is None:
            atm_files = [self.Envi.atm_file]
        hitran_path = self.Envi.hit_file
        
        file = open(filename, 'w')

        file.write('*HDR\n       ')
        file.write('RFM Driver file generated by RFM tools.\n')
        file.write('*FLG\n       ')
        file.write('OBS TRA RAD ZEN DBL      !\n')
        file.write('*SPC\n       ')
        file.write(str(wmin)+' '+str(wmax)+' '+str(sampling)+'\n')
        file.write('*GAS\n       ')
        for mol in mols:
            file.write(mol+' ')
        file.write('\n')
        file.write('*ATM\n      ')
        for atm_file in atm_files:
            file.write(atm_file+'\n')
        file.write('*TAN\n      ')
        file.write(str(am)+'\n')
        file.write('*HIT\n      ')
        file.write(hitran_path+'\n')
        file.write('*OBS\n      ')
        file.write(str(alt)+'\n')
        file.write('*TRA\n      ')
        file.write(self.outname+'\n')
        file.write('*RAD\n      ')
        file.write('rfm.rad\n')
        file.write('*END\n')

        file.close()

    def readFromFile(self,filename):
        
        ccond = re.compile('\!')
        
        file = open(filename,'r')
        lines = file.readlines()

        first_line_read = False

        data = np.array([])
        for line in lines:
            #Is it a comment line?
            if not ccond.search(line):
                #Is it the first line?
                if not first_line_read:
                    first_line = line.split()
                    npoints  = int(first_line[0])
                    wmin     = float(first_line[1])
                    sampling = float(first_line[2])
                    wmax     = float(first_line[3])
                    label    = first_line[4]
                    label_len = len(label)
                    #Remove inverted commas
                    label = label[1:label_len-1]

                    first_line_read = True
                else:
                    data = np.append(data,[float(s) for s in line.split()])
 
        file.close()

        wave = np.linspace(wmin,wmax,npoints)

        #Everything in order of increasing wavelength
        return {'wavelength':1e4/wave[::-1],'wavenumber':wave[::-1],label:data[::-1]}
        
    def blur(self,rpower=1e5):
        wave = self.spectrum['wavelength']
        tran = self.spectrum['Transmission']
        radi = self.radiance['Radiance']
        
        wmin = wave.min()
        wmax = wave.max()
        
        nx = wave.size
        x  = np.arange(nx)
        
        A = wmin
        B = np.log(wmax/wmin)/nx
        wave_constfwhm = A*np.exp(B*x)

        tran_constfwhm = np.interp(wave_constfwhm, wave, tran)        
        radi_constfwhm = np.interp(wave_constfwhm, wave, radi)  
        
        #Sanity check that the FWHM is indeed constant
        dwdx_constfwhm = np.diff(wave_constfwhm)
        fwhm_pix = wave_constfwhm[1:]/rpower/dwdx_constfwhm
        if (fwhm_pix.min()-fwhm_pix.max())/fwhm_pix.max() > 1e-5: 
            #This should not happen
            warnings.warn('The FWHM is not constant in units of pixels.')
        
        fwhm_pix  = fwhm_pix[0]
        sigma_pix = fwhm_pix/2.3548
        kx = np.arange(nx)-(nx-1)/2.
        kernel = 1./(sigma_pix*np.sqrt(2.*np.pi))*np.exp(-kx**2/(2.*sigma_pix**2)) 
        
        tran_conv = fft.ifft(fft.fft(tran_constfwhm)*np.conj(fft.fft(kernel)))
        tran_conv = fft.fftshift(tran_conv).real
        tran_oldsampling = np.interp(wave,wave_constfwhm,tran_conv)

        radi_conv = fft.ifft(fft.fft(radi_constfwhm)*np.conj(fft.fft(kernel)))
        radi_conv = fft.fftshift(radi_conv).real
        radi_oldsampling = np.interp(wave,wave_constfwhm,radi_conv)

        self.obs_spectrum = {'wavelength':wave,'wavenumber':1e4/wave, 
                             'Transmission':tran_oldsampling,'Radiance':radi_oldsampling}

        return self.obs_spectrum

    def getSpec(self):
        return self.obs_spectrum

    def plot(self,unit='cm-1'):
        if unit=='micron':
            plt.plot(self.obs_spectrum['wavelength'],self.obs_spectrum['Transmission'])
            plt.show()
        elif unit=='cm-1':
            plt.plot(self.obs_spectrum['wavenumber'],self.obs_spectrum['Transmission'])
            plt.show()
        else:
            raise Exception("Unknown unit in model plot")

class QuickRed():
    def __init__(self,flat_range=None, flat_dark_range=None, dark_range=None,
                sci_range=None, std_range=None, path=None, base=None,level1=True,level2=True,
                level1_path='L1FILES',shift=0.0, dtau=0.0, save_dark=False, save_flat=False, SettingsFile=None,
                sci_tname=None, std_tname=None, hold_plots=True, hold=True, **kwargs):

        if (hold == False):
            hold_plots = False

        self.save_dark = save_dark
        self.save_flat = save_flat

        sci_range1 = sci_range
        self.shift       = shift
        self.dtau        = dtau
        self.level1_path = level1_path

        self.SettingsFile = SettingsFile

        self.flat_dark_names = pn.makeFilelist(base,flat_dark_range,path=path)
        self.obs_dark_names  = pn.makeFilelist(base,dark_range,path=path)
        self.flat_names      = pn.makeFilelist(base,flat_range,path=path)
        self.sci_names1      = pn.makeFilelist(base,sci_range1,path=path)
        self.std_names       = pn.makeFilelist(base,std_range,path=path)

        self.mode  = 'SciStd'
        self.tdict = {'science':self.sci_names1,'standard':self.std_names}
        self.ndict = {'science':sci_tname, 'standard':std_tname}
        self.hold_plots = hold_plots

        if level1:
            self._level1()


    def _level1(self):
        FDark = pn.Dark(self.flat_dark_names)
        ODark = pn.Dark(self.obs_dark_names,save=self.save_dark)
        OFlat = pn.Flat(self.flat_names, dark=FDark,save=self.save_flat, SettingsFile=self.SettingsFile)

        level1_files = {}
        for key in self.tdict.keys():
            ONod    = pn.Nod(self.tdict[key],flat=OFlat,dark=ODark, tname=self.ndict[key], SettingsFile=self.SettingsFile) 
            norders = ONod.getNOrders()
            target_files = []
            for i in np.arange(norders):
                print '### Processing order', i+1
                OOrder   = pn.Order(ONod,onum=i+1,write_path='foo')
                print '### 2D order extracted'
                OSpec1D  = pn.Spec1D(OOrder,sa=True,write_path='foo')
                OWaveCal = pn.WaveCal(OSpec1D.file,path='wave_o',am=OSpec1D.airmass, hp=self.hold_plots)


class WaveCal_st():
	def __init__(self, ObsFilename=None, ModelFilename=None, wave_min=None, wave_max=None, cull=50, am=1.0, H2O_scale=1.0, CO_scale=1.0, CH4_scale=1.0, CO2_scale=1.0, vrad=0.0, vbary=0.0):
                
		## SETUP MODEL ATMOSPHERE ##
		Envi = rfm.Environment()
		A = rfm.Atmosphere(filename=Envi.atm_file)
		A.scaleProf('H2O', H2O_scale)
		A.scaleProf('CO', CO_scale)
		A.scaleProf('CH4', CH4_scale)
		A.scaleProf('CO2', CO2_scale)
		A.writeAll('tmp.atm')
		self.A = A

		M = Model()
		M.RFM(atm_files=['tmp.atm'],wmin=1e4/wave_max,wmax=1e4/wave_min, am=am)
		M.blur(rpower=25000.)
		self.M = M

		## GET MODEL SKY SPECTRUM ##
		ModInfo = M.getSpec()
		self.WaveMod  = ModInfo['wavelength']
		self.SkyRadMod = ModInfo['Radiance'] / np.amax(ModInfo['Radiance'])
		self.SkyRadMod = 1 - self.SkyRadMod
		scale = np.amax(self.SkyRadMod)

		## GET MODEL STELLAR SPECTRUM ##
		a = np.loadtxt(ModelFilename, skiprows=1)
		StellWL, StellFlux = 1e4/a[:,0], a[:,1]
		plt.plot(StellWL,StellFlux)
		if np.all(np.diff(StellWL) > 0) != True:
			StellWL = np.flip(StellWL,0)
			StellFlux = np.flip(StellFlux,0)
        
        
		## BROADEN STELLAR SPECTRUM ##
		StellFlux_Broad = self.blur_function(StellWL, StellFlux, 25000.)
		print StellFlux_Broad
		plt.plot(StellWL,StellFlux_Broad)
		plt.show()

		## SHIFT STELLAR SPECTRUM ## 
		StellWave_Shift = self.shift_wavelength(StellWL, vrad-vbary)
		print StellWL
		print StellWave_Shift

		## INTERPOLATE STELLAR SPECTRUM ONTO COMMON WAVELENGTH GRID ##
		self.StellFlux_Interp = np.interp(self.WaveMod, StellWave_Shift, StellFlux_Broad)

		## COMBINE STELLAR AND TELLURIC SPECTRA ##
		assert(np.shape(self.StellFlux_Interp) == np.shape(self.SkyRadMod))
		self.StellFlux_Interp = self.StellFlux_Interp / np.median(self.StellFlux_Interp)
		self.SkyRadMod = self.SkyRadMod / np.median(self.SkyRadMod)
		self.ModSpec = 1.0*self.StellFlux_Interp + 0.8*self.SkyRadMod           ####change these to change ratios - SkyRadMod = telluric
		self.ModSpec = self.ModSpec / np.median(self.ModSpec)
		## colors combined model to show tell vs stell contributions
		self.color = self.colorinmodel(self.StellFlux_Interp,self.SkyRadMod)
		plt.figure()
		plt.plot(self.WaveMod, self.StellFlux_Interp, label='stell')
		plt.plot(self.WaveMod, self.SkyRadMod, label='tell')
		#plt.plot(self.WaveMod, self.ModSpec, label='stell+tell')
		self.plot_multicolored_lines(self.WaveMod, self.ModSpec,self.color,label='stell(c)+tell(k)')
		plt.legend(loc=0)

		## GET OBSERVED SKY ##
		ObsInfo    = nt.WaveOrder(ObsFilename).getData()
		WaveObsPos = np.array(ObsInfo['wl_pos'])
		#        SkyObsPos  = np.array(ObsInfo['sky_pos']) / np.median(ObsInfo['sky_pos'])  # L BAND
		SkyObsPos  = np.array(ObsInfo['flux_pos']) / np.median(ObsInfo['flux_pos']) # K BAND
		WaveObsNeg = np.array(ObsInfo['wl_neg'])
		#        SkyObsNeg  = np.array(ObsInfo['sky_neg']) / np.median(ObsInfo['sky_neg'])  # L BAND
		SkyObsNeg  = np.array(ObsInfo['flux_neg']) / np.median(ObsInfo['flux_neg']) # K BAND
        
        ## FIT OUT CONTINUUM ## (DP 21 JAN 16)
		wn_data_all = [WaveObsPos, WaveObsNeg]
		flux_data_all = [SkyObsPos, SkyObsNeg]
		merp = 16 #64 ##32 #16
		factor = 64 #16 #32# 64
		posneg = 0
		baseline_pos, baseline_neg = np.ones(np.size(WaveObsPos)), np.ones(np.size(WaveObsNeg))
#        SkyObsPos_contrmv, SkyObsNeg_contrmv = np.array(np.size(SkyObsPos)), np.array(np.size(SkyObsNeg))
		for wn_data, flux_data in zip(wn_data_all, flux_data_all) : 
			points_flux, points_wn, points_count =np.zeros(merp), np.zeros(merp), np.arange(merp)
			for count in points_count :
				startpoint = count*factor
				endpoint = (count+1)*factor
				if count == 0 : startpoint = 14
				if count == 15 : endpoint = 1024-30
				#                if count==63 : endpoint = 1024-14
				points_flux[count]=np.max(flux_data[startpoint:endpoint])
				loc=np.argmax(flux_data[startpoint:endpoint])
#                points_wn[count]=wn_data[loc+startpoint]
				points_wn[count]=loc+startpoint
			coeff = np.polyfit(points_wn, points_flux, 2)   
#            coeff = np.polyfit(points_wn, points_flux, 4)      
			print coeff
#            if posneg == 0 : baseline_pos = coeff[1] + coeff[0]*wn_data# + coeff[1]*wn_data**2 + coeff[0]*wn_data**3
#            if posneg == 1 : baseline_neg = coeff[1] + coeff[0]*wn_data# + coeff[1]*wn_data**2 + coeff[0]*wn_data**3
			if posneg == 0 : baseline_pos = coeff[2] + coeff[1]*np.arange(1024) + coeff[0]*np.arange(1024)**2# + coeff[0]*np.arange(1024)**3
			if posneg == 1 : baseline_neg = coeff[2] + coeff[1]*np.arange(1024) + coeff[0]*np.arange(1024)**2# + coeff[0]*np.arange(1024)**3
#            if posneg == 0 : baseline_pos = coeff[4] + coeff[3]*np.arange(1024) + coeff[2]*np.arange(1024)**2 + coeff[1]*np.arange(1024)**3 + coeff[0]*np.arange(1024)**4# + coeff[0]*np.arange(1024)**3
#            if posneg == 1 : baseline_neg = coeff[4] + coeff[3]*np.arange(1024) + coeff[2]*np.arange(1024)**2 + coeff[1]*np.arange(1024)**3 + coeff[0]*np.arange(1024)**4# + coeff[0]*np.arange(1024)**3
			posneg += 1
		SkyObsPos_contrmv, SkyObsNeg_contrmv = SkyObsPos / baseline_pos, SkyObsNeg / baseline_neg
		self.ModSpec = 1 - self.ModSpec
		plt.figure()
		plt.plot(SkyObsPos, hold=True)
		plt.plot(baseline_pos, hold=True)
		plt.show()
		plt.figure()
		plt.plot(SkyObsNeg, hold=True)
		plt.plot(baseline_neg, hold=True)
		plt.show()

		self.ObsLabelPN = ['pos', 'neg']
		### break spec into 4 pieces
		#fourth = int(len(WaveObsPos)/4)
		#Wavepos = []
		#Waveneg = []
		#for val in range(fourth):
		#    Wavepos.append(WaveObsPos[val])
		#    Waveneg.append(WaveObsNeg[val])
		self.WaveObsPN = [WaveObsPos, WaveObsNeg]
		SkyObsPos_contrmv_scaled = (1 - SkyObsPos_contrmv)
		SkyObsNeg_contrmv_scaled = (1 - SkyObsNeg_contrmv)
		self.Pixels = [np.arange(len(WaveObsPos)), np.arange(len(WaveObsNeg))]
		self.SkyObsPN_orig  = [SkyObsPos, SkyObsNeg]
		self.SkyObsPN  = [SkyObsPos_contrmv_scaled, SkyObsNeg_contrmv_scaled]
		self.GoodFit = [False, False]

		self.Coefs, self.WaveObsPN = self.FitInitDS(self.WaveObsPN, self.ObsLabelPN)
        
        
		secs = ['one','two','three','four']
		for sec in secs:
			sec = 'full'
			print "======================"
			print "======================"
			print 'QUARTER', sec
			print "======================"
			print "======================"
			while(True):
				RawInput = raw_input('>> ').replace(" ", "").lower()
				if (RawInput == 'quit'):
					break

				if (RawInput == 'pos'):
					RawInput2 = raw_input("Pos. Coefficients?: ").split(",")
					self.Coefs[0] = np.array(RawInput2, dtype=np.float)
					self.WaveObsPN[0] = self.DSFunc(self.Pixels[0], self.Coefs[0])
			
			
					modflux, newfl_obs = self.comparemodelanddata(self.WaveMod, self.ModSpec, self.WaveObsPN[0], self.SkyObsPN[0])
					if sec == 'full':
						self.PlotModObs(self.WaveMod, modflux, self.WaveObsPN[0], newfl_obs, self.ObsLabelPN[0])
			
					else:
						wvm, fm, wvo, fo = self.Breakintofour(self.WaveMod, modflux, self.WaveObsPN[0], newfl_obs,section=sec)
						self.PlotModObs(wvm, fm, wvo, fo, self.ObsLabelPN[0])

			
				if (RawInput == 'neg'):
					RawInput2 = raw_input("Neg. Coefficients?: ").split(",")
					self.Coefs[1] = np.array(RawInput2, dtype=np.float)
					self.WaveObsPN[1] = self.DSFunc(self.Pixels[1], self.Coefs[1])
			
			
					modflux, newfl_obs = self.comparemodelanddata(self.WaveMod, self.ModSpec, self.WaveObsPN[1], self.SkyObsPN[1])
					if sec == 'full':
						self.PlotModObs(self.WaveMod, modflux, self.WaveObsPN[1], newfl_obs, self.ObsLabelPN[1])
					else:
						wvm, fm, wvo, fo = self.Breakintofour(self.WaveMod, modflux, self.WaveObsPN[1], newfl_obs,section=sec)
						self.PlotModObs(wvm, fm, wvo, fo, self.ObsLabelPN[1])
			
			
				if (RawInput == 'fit'):
					for i in range(0,len(self.Coefs)):
						if (self.GoodFit[i] != True):

							#self.Coefs[i], self.WaveObsPN[i] = self.FitDS(self.WaveMod, self.ModSpec, self.SkyObsPN[i], self.Coefs[i])
					
					
							modflux, newfl_obs = self.comparemodelanddata(self.WaveMod, self.ModSpec, self.WaveObsPN[i], self.SkyObsPN[i])
							if sec == 'full':
								self.Coefs[i], self.WaveObsPN[i] = self.FitDS(self.WaveMod, modflux, newfl_obs, self.Coefs[i])                                   
								self.PlotModObs(self.WaveMod, modflux, self.WaveObsPN[i], newfl_obs, self.ObsLabelPN[i])
							else:
								wvm, fm, wvo, fo = self.Breakintofour(self.WaveMod, modflux, self.WaveObsPN[i], newfl_obs,section=sec)
								self.Coefs[i], self.WaveObsPN[i] = self.FitDS(wvm, fm, fo, self.Coefs[i])                                   
								self.PlotModObs(wvm, fm, self.WaveObsPN[i], fo, self.ObsLabelPN[i])
					
							RawInput2 = raw_input("Good Fit? (yes/no): ").replace(" ", "").lower()
							while (True):
								if (RawInput2 == 'yes'):
									self.GoodFit[i] = True
									break
								if (RawInput2 == 'no'):
									break
								else:
									print "Please type yes or no."
									break
						else:
							print ''
							print '## Dispersion Solution for ' + self.ObsLabelPN[i] + ' position is good.'

				if (RawInput == 'pf'):
					self.PrintCoefs()
			
			if sec == 'full':
				break	
    
	def find_contiguous_colors(self,colors):
		# finds the continuous segments of colors and returns those segments
		segs = []
		curr_seg = []
		prev_color = ''
		for c in colors:
			if c == prev_color or prev_color == '':
				curr_seg.append(c)
			else:
				segs.append(curr_seg)
				curr_seg = []
				curr_seg.append(c)
			prev_color = c
		segs.append(curr_seg) # the final one
		return segs
    
	def plot_multicolored_lines(self,x,y,colors,label=None):
		segments = self.find_contiguous_colors(colors)
		#plt.figure()
		start= 0
		for num,seg in enumerate(segments):
			if num == 0:
				end = start + len(seg)
				l, = plt.gca().plot(x[start:end],y[start:end],c=seg[0],label=label) 
				start = end    
			else:
				end = start + len(seg)
				l, = plt.gca().plot(x[start:end],y[start:end],c=seg[0]) 
				start = end  
                             
	def colorinmodel(self,stellflux,tellflux):
		color = []
		for i,j in zip(stellflux,tellflux):
			if j < i:   ##tell
				color.append('k')
			else:
				color.append('c')               
		return color
    
    
	def comparemodelanddata(self,modelwave,modelflux,obswave,obsflux):
		## normalizes the model and data so they're on about the same scale
		fl_mod = []
		fl_obs = []
                
                
		if np.nanmax(modelflux) > np.nanmax(obsflux):
			for a in modelflux:  
				fl_mod.append(a/list(modelflux)[np.argmax(obsflux)])
			for b in obsflux:     
				fl_obs.append(b/np.nanmax(obsflux))
		elif np.nanmax(modelflux) < np.nanmax(obsflux):
			wave_max = modelwave[np.argmax(modelflux)]

			for num,x in enumerate(obswave):
				if x > wave_max - 0.05 and x < wave_max + 0.05:
					index = num
					break
				else:
					index = 0

			### to find index of second largest flux in obs flux
			arr = np.array(obsflux)
			secondlargest = arr.argsort()[-5:][0]		## make number bigger to pick smaller flux index
            
			for a in modelflux:        
				fl_mod.append(a/np.nanmax(modelflux))
			for b in obsflux:     
				#fl_obs.append((b/list(obsflux)[index])-0.05)
				#fl_obs.append((b/np.nanmax(obsflux))-0.05)
				fl_obs.append((b/list(obsflux)[secondlargest])-0.05)        
        
		fl_mod = np.array(fl_mod)
		fl_obs = np.array(fl_obs)
        
        
		return fl_mod, fl_obs


	def Breakintofour(self,modelwave,modelflux,obswave,obsflux,section='one'):
		mod_num = len(modelwave)
		obs_num = len(obswave)
        
		if section == 'one':
			new_modwave = modelwave[0:int(mod_num/4.0)]
			new_modflux = modelflux[0:int(mod_num/4.0)]
			new_obswave = obswave[0:int(obs_num/4.0)]
			new_obsflux = obsflux[0:int(obs_num/4.0)]
		elif section == 'two':
			new_modwave = modelwave[int(mod_num/4.0):int(2.0*mod_num/4.0)]
			new_modflux = modelflux[int(mod_num/4.0):int(2.0*mod_num/4.0)]
			new_obswave = obswave[int(obs_num/4.0):int(2.0*obs_num/4.0)]
			new_obsflux = obsflux[int(obs_num/4.0):int(2.0*obs_num/4.0)]
		elif section == 'three':
			new_modwave = modelwave[int(2.0*mod_num/4.0):int(3.0*mod_num/4.0)]
			new_modflux = modelflux[int(2.0*mod_num/4.0):int(3.0*mod_num/4.0)]
			new_obswave = obswave[int(2.0*obs_num/4.0):int(3.0*obs_num/4.0)]
			new_obsflux = obsflux[int(2.0*obs_num/4.0):int(3.0*obs_num/4.0)]
		elif section == 'four':
			new_modwave = modelwave[int(3.0*mod_num/4.0):int(4.0*mod_num/4.0)]
			new_modflux = modelflux[int(3.0*mod_num/4.0):int(4.0*mod_num/4.0)]
			new_obswave = obswave[int(3.0*obs_num/4.0):int(4.0*obs_num/4.0)]
			new_obsflux = obsflux[int(3.0*obs_num/4.0):int(4.0*obs_num/4.0)]
        
		return new_modwave, new_modflux, new_obswave, new_obsflux
    
	def PrintCoefs(self):
        
		Clab = ['A = ', 'B = ', 'C = ', 'D = ', 'E = ']

		for coef, label, goodf in zip(self.Coefs,self.ObsLabelPN, self.GoodFit):
			print ''
			print 'Position = ', label
			print 'Good Fit = ', goodf
			print '-------------------'
			for i in range(0,len(coef)):
				print Clab[i], coef[i]
			print ''
    	
	def ReadAux(self, FileName):
		''' 
		Reads in auxillary data files from Terraspec or another source.
		'''
		FileInfo = np.loadtxt(FileName, skiprows=1, dtype='float')
		wn   = FileInfo[:,0]
		flux = FileInfo[:,1]
		wl = 1.0e4 / wn
		
		if np.size(wl) > 1024 : 
			sec_out = np.where((wl >= self.WaveMin) & (wl <= self.WaveMax))
			wl_out   = wl[sec_out]
			flux_out = flux[sec_out]
		else :
			wl_out = wl
			flux_out = flux
		
		return wl_out, flux_out
    
	def PlotModObs(self, wave_mod, flux_mod, wave_obs, flux_obs, label, block=False):
		plt.close()
		plt.figure(figsize=(20, 10))
		#plt.plot(wave_mod, flux_mod, color='blue')
		self.plot_multicolored_lines(wave_mod,flux_mod,self.color)    ### this tells stel (c) vs tel (k) lines
		#plt.plot(wave_obs, flux_obs, color='red')
		x1,x2,y1,y2 = plt.axis()
		plt.axis((x1, x2, np.amin([np.amin(flux_mod), np.amin(flux_obs)]), np.amax(flux_mod)))
		plt.title(label)
        
		plt.figure(figsize=(20, 10))
		plt.plot(wave_mod, flux_mod, color='blue')
		#self.plot_multicolored_lines(wave_mod,flux_mod,self.color)    ### this tells stel vs tel lines
		plt.plot(wave_obs, flux_obs, color='red')
		x1,x2,y1,y2 = plt.axis()
		plt.axis((x1, x2, np.amin([np.amin(flux_mod), np.amin(flux_obs)]), np.amax(flux_mod)))
		plt.title(label)
		plt.show()
		#plt.savefig('/home/cbuzard/Desktop/temp.pdf')
		
	def FitInitDS(self, WaveLengths, Labels):
		porder = 1
		Coefs, WaveLengths_fit = [], []

		print 'Initial Coefficients'
		print '===================='

		for wl, label in zip(WaveLengths, Labels):
			pixels = np.arange(len(wl))

			coef = np.polyfit(pixels, wl, porder)[::-1]
			wl_fit = self.DSFunc(pixels, coef)

			print '# ' + label + ' #'
			print '---------------'
			for i in range(0, porder+1):
				print i, coef[i]
			print ''

			plt.plot(pixels, wl, 'ko')
			plt.plot(pixels, wl_fit)
			plt.show()

			Coefs.append(coef)
			WaveLengths_fit.append(wl_fit)

		return Coefs, WaveLengths_fit

	def DSFunc(self, pixels, Coefs):

		WaveOut = np.zeros(len(pixels))
		for i in range(0,len(Coefs)):
			if i <= 1:
				WaveOut = WaveOut + Coefs[i]*(pixels)**i
			else:
				WaveOut = WaveOut + Coefs[i]*(pixels/1000.)**i

		return WaveOut

	def residual(self, params, flux_data, wl_model, flux_model):
		npix = len(flux_data)
		pixels = np.arange(npix)
    
		Coefs = [params['A'].value, params['B'].value, params['C'].value, params['D'].value, params['E'].value]#, params['F'].value]
		wl_fit = self.DSFunc(pixels, Coefs)

		flux_model_fit = np.interp(wl_fit, wl_model, flux_model, left=flux_model[0], right=flux_model[-1])
             
		index_use = np.where(flux_data > 0.005)
        
		residual = np.subtract(flux_model_fit[index_use], flux_data[index_use])
            
		return (residual)
    
	def FitDS(self, WLmod, Fmod, Fobs, CoefsInit):

		params = Parameters()
		params.add('A',value=CoefsInit[0], vary=True,min=CoefsInit[0]-0.005,max=CoefsInit[0]+0.005)
		params.add('B',value=CoefsInit[1], vary=True)
		params.add('C',value=1e-5, vary=True)
		params.add('D',value=1e-6, vary=True)
		params.add('E',value=1e-6, vary=True)
#        params.add('F',value=1e-6, vary=True)

		result = minimize(self.residual, params, args=(Fobs, WLmod, Fmod), method='powell-sq') #'least-sq')
		params = result.params
		print ''
		print '-----'
		print 'A = ', params['A']
		print 'B = ', params['B'] 
		print 'C = ', params['C']
		print 'D = ', params['D']
		print 'E = ', params['E']
#        print 'F=  ', params['F']
		#print 'R = ', params['R']
		print 'RedChi / Success = ', result.redchi, ' / ', result.success
		print ''
		print '====='

		Coefs = [params['A'].value, params['B'].value, params['C'].value, params['D'].value, params['E'].value]#, params['F'].value]
		pixels = np.arange(len(Fobs))
		WLobs = self.DSFunc(pixels, Coefs)

		return Coefs, WLobs

	def blur_function(self, wave, tran, rpower):
        
		wmin = wave.min()
		wmax = wave.max()
        
		nx = wave.size
		x  = np.arange(nx)
        
		A = wmin
		B = np.log(wmax/wmin)/nx
		wave_constfwhm = A*np.exp(B*x)

		if np.all(np.diff(wave) > 0) != True:
			print "wave list not increasing"
			wave = np.flip(wave,0)
			tran = np.flip(tran,0)
		tran_constfwhm = np.interp(wave_constfwhm, wave, tran)        
        
		#Sanity check that the FWHM is indeed constant
		dwdx_constfwhm = np.diff(wave_constfwhm)
		fwhm_pix = wave_constfwhm[1:]/rpower/dwdx_constfwhm
		if (fwhm_pix.min()-fwhm_pix.max())/fwhm_pix.max() > 1e-5: 
            #This should not happen
			warnings.warn('The FWHM is not constant in units of pixels.')
        
		fwhm_pix  = fwhm_pix[0]
		sigma_pix = fwhm_pix/2.3548
		kx = np.arange(nx)-(nx-1)/2.
		kernel = 1./(sigma_pix*np.sqrt(2.*np.pi))*np.exp(-kx**2/(2.*sigma_pix**2)) 
        
		tran_conv = fft.ifft(fft.fft(tran_constfwhm)*np.conj(fft.fft(kernel)))
		tran_conv = fft.fftshift(tran_conv).real
		tran_oldsampling = np.interp(wave,wave_constfwhm,tran_conv)

		return tran_oldsampling
    
	def shift_wavelength(self, wave, velshift) :
        # velshift = velocity shift in km/s # vrad-vbary #
		c = 2.99792456e5 # speed of light in km/s
        
		wavelength_wn = 1.0e4/wave
		shift_wavelength_wn = wavelength_wn / (1.0+(velshift)/c)
		newwave = 1.0e4/shift_wavelength_wn # StarSpec[:,0] / (1.0+(vrad-vbary)/c)
        
		return newwave
